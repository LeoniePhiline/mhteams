//!
//! MHteams provides an easy and idiomatic way of creating and sending messages to MS Teams webhooks.
//! 
//! Message card type.
//! 
//! Most documentation in this module are from
//! [microsoft docs](https://docs.microsoft.com/en-us/outlook/actionable-messages/message-card-reference).
//! 

extern crate serde;
extern crate serde_json;

use serde::{Serialize, Serializer};

#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize)]
pub struct Message<'a> {
    /// Required to always be set to "MessageCard"
    #[serde(rename = "@type")]
    typ: &'a str,

    /// Required to always be set to "https://schema.org/extensions"
    #[serde(rename = "@context")]
    context: &'a str,

    /// Required if the card does not contain a `text` property, otherwise optional. 
    /// The `summary` property is typically displayed in the list view in Outlook, 
    /// as a way to quickly determine what the card is all about.
    ///
    /// **Do** always include a summary.  
    /// 
    /// **Don't** include details in the summary. For example, for a Twitter post, 
    /// a summary might simply read "New tweet from @someuser" without mentioning
    /// the content of the tweet itself.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub summary: String,

    /// Specifies a custom brand color for the card. The color will be displayed
    /// in a non-obtrusive manner.
    #[serde(rename = "themeColor", skip_serializing_if = "String::is_empty")]
    pub theme_color: String,

    /// The `correlationId` property simplifies the process of locating logs for
    /// troubleshooting issues. We recommend that when sending an actionable card,
    /// your service should set and log a unique UUID in this property.
    ///
    /// When the user invokes an action on the card, Office 365 sends the `Card-Correlation-Id`
    /// and `Action-Request-Id` headers in the POST request to your service.
    /// `Card-Correlation-Id` contains the same value as the `correlationId`
    /// property in the card. `Action-Request-Id` is a unique UUID generated by
    /// Office 365 to help locate specific action performed by a user. Your
    /// service should log both of these values when receiving action POST requests.
    #[serde(rename = "correlationId", skip_serializing_if = "usize_is_zero")]
    pub correlation_id: usize,

    /// Optional. This contains a list of expected email addresses of the
    /// recipient for the action endpoint.
    ///
    /// A user can have multiple email addresses and the action endpoint might
    /// not be expecting the particular email address presented in the `sub` claim
    /// of the bearer token. For example, a user could have both the `john.doe@contoso.com`
    /// or `john@contoso.com` email address, but the action endpoint expects to receive
    /// `john@contoso.com` in the `sub` claim of the bearer token. By setting
    /// this field to `["john@contoso.com"]`, the `sub` claim will have the
    /// expected email address.
    #[serde(rename = "expectedActors", skip_serializing_if = "Vec::is_empty")]
    pub expected_actors: Vec<String>,

    /// Required when sent via email, not applicable when sent via connector.
    /// For actionable email, MUST be set to the provider ID generated by the
    /// Actionable Email Developer Dashboard.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub originator: String,

    /// _Only applies to cards in email messages_
    ///
    /// When set to true, causes the HTML body of the message to be hidden. This
    /// is very useful in scenarios where the card is a better or more useful
    /// representation of the content than the HTML body itself, which is especially
    /// true when the card contains actions (see below.)
    ///
    /// Consider hiding the original HTML body:
    /// * If the card itself contains all the information a user would need
    /// * If the content of the card is redundant with the content of the body
    ///
    /// **Do** always include a nice HTML body, even if it is going to be hidden.
    /// The HTML body is the only thing an email client that doesn't support cards
    /// will be able to display. Furthermore, cards are not included when replying
    /// to or forwarding emails, only the HTML body.
    /// 
    /// **Don't** hide the body when it is complementary to the information presented
    /// in the card. For example, the body of an expense report approval might
    /// describe the report in great details while the card just presents a quick
    /// summary along with approve/decline actions.
    #[serde(rename = "hideOriginalBody", skip_serializing_if = "Option::is_none", serialize_with = "optional_bool")]
    pub hide_original_body: Option<bool>,

    /// The `title` property is meant to be rendered in a prominent way, at the
    /// very top of the card. Use it to introduce the content of the card in such
    /// a way users will immediately know what to expect.
    /// 
    /// Examples:
    /// * Daily news
    /// * New bug opened
    /// * Task <name of task> assigned
    ///
    /// **Do** keep title short, don't make it a long sentence.
    /// 
    /// **Do** mention the name of the entity being referenced in the title.
    /// 
    /// **Don't** use hyperlinks (via Markdown) in the title.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub title: String,

    /// Required if the card does not contain a `summary` property, otherwise optional.
    /// The `text` property is meant to be displayed in a normal font below the card's
    /// title. Use it to display content, such as the description of the entity
    /// being referenced, or an abstract of a news article.
    /// 
    /// **Do** use simple Markdown, such as bold or italics to emphasize words,
    /// and links to external resources.
    /// 
    /// **Don't** include any call to action in the text property. Users should be
    /// able to not read it and still understand what the card is all about.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub text: String,

    /// A collection of [`sections`] to include in the card.
    /// 
    /// [`sections`]: struct.Section.html
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub sections: Vec<Section>,

    /// A collection of [`actions`] that can be invoked on this card.
    /// 
    /// [`actions`]: struct.Action.html
    #[serde(rename = "potentialAction", skip_serializing_if = "Vec::is_empty")]
    pub potential_action: Vec<Action>,
}

impl<'a> Message<'a> {
    pub fn new() -> Message<'a> {
        Message {
            typ: "MessageCard",
            context: "https://schema.org/extensions",
            ..Default::default()
        }
    }
}

#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize)]
pub struct Section {
    /// The `title` property of a section is displayed in a font that stands out
    /// while not as prominent as the card's title. It is meant to introduce the
    /// section and summarize its content, similarly to how the card's title
    /// property is meant to summarize the whole card.
    ///
    /// **Do** keep title short, don't make it a long sentence.
    /// 
    /// **Do** mention the name of the entity being referenced in the title.
    /// 
    /// **Don't** use hyperlinks (via Markdown) in the title.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub title: String,

    /// When set to `true`, the `startGroup` property marks the start of a logical
    /// group of information. Typically, sections with `startGroup` set to `true`
    /// will be visually separated from previous card elements. For example,
    /// Outlook uses a subtle horizontal separation line.
    /// 
    /// **Do** use `startGroup` to separate sections that represent different objects;
    /// for example, multiple tweets in a digest.
    #[serde(rename = "startGroup", skip_serializing_if = "Option::is_none", serialize_with = "optional_bool")]
    pub start_group: Option<bool>,

    /// These four properties form a logical group. `activityTitle`, `activitySubtitle`
    /// and `activityText` will be displayed alongside `activityImage`, using a
    /// layout appropriate for the form factor of the device the card is being
    /// viewed on. For instance, in Outlook on the Web, `activityTitle`,
    /// `activitySubtitle` and `activityText` are displayed on the right of `activityImage`, using a two-column layout.
    #[serde(rename = "activityImage", skip_serializing_if = "String::is_empty")]
    pub activity_image: String,

    /// These four properties form a logical group. `activityTitle`, `activitySubtitle`
    /// and `activityText` will be displayed alongside `activityImage`, using a
    /// layout appropriate for the form factor of the device the card is being
    /// viewed on. For instance, in Outlook on the Web, `activityTitle`,
    /// `activitySubtitle` and `activityText` are displayed on the right of `activityImage`, using a two-column layout.
    #[serde(rename = "activityTitle", skip_serializing_if = "String::is_empty")]
    pub activity_title: String,

    /// These four properties form a logical group. `activityTitle`, `activitySubtitle`
    /// and `activityText` will be displayed alongside `activityImage`, using a
    /// layout appropriate for the form factor of the device the card is being
    /// viewed on. For instance, in Outlook on the Web, `activityTitle`,
    /// `activitySubtitle` and `activityText` are displayed on the right of `activityImage`, using a two-column layout.
    #[serde(rename = "activitySubtitle", skip_serializing_if = "String::is_empty")]
    pub activity_subtitle: String,

    /// These four properties form a logical group. `activityTitle`, `activitySubtitle`
    /// and `activityText` will be displayed alongside `activityImage`, using a
    /// layout appropriate for the form factor of the device the card is being
    /// viewed on. For instance, in Outlook on the Web, `activityTitle`,
    /// `activitySubtitle` and `activityText` are displayed on the right of `activityImage`, using a two-column layout.
    #[serde(rename = "activityText", skip_serializing_if = "String::is_empty")]
    pub activity_text: String,

    /// Use `heroImage` to make an image the centerpiece of your card. For example,
    /// a tweet that contains an image will want to put that image front and center.
    #[serde(rename = "heroImage", skip_serializing_if = "Option::is_none", serialize_with = "optional_image")]
    pub hero_image: Option<bool>,

    /// The section's `text` property is very similar to the `text` property of
    /// the card. It can be used for the same purpose.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub text: String,

    /// Facts are a very important component of a section. They often contain
    /// the information that really matters to the user.
    /// 
    /// Facts are displayed in such a way that they can be read quickly and
    /// efficiently. For example, in Outlook on the Web, facts are presented in
    /// a two-column layout, with fact names rendered in a slightly more prominent font.
    /// 
    /// **Do** use facts instead of embedding important information inside the text
    /// property of either the card or the section.
    /// 
    /// **Do** keep fact names short.
    /// 
    /// **Avoid** making fact values too long.
    /// 
    /// **Avoid** using Markdown formatting for both fact names and values. Let
    /// facts be rendered as intended as that is how they will have the most impact.
    /// 
    /// **Do** however use Markdown for links in fact values only. For instance,
    /// if a fact references an external document, make the value of that fact
    /// a link to the document.
    /// 
    /// **Don't** add a fact without a real purpose. For instance, a fact that
    /// would always have the same value across all cards is not interesting
    /// and a waste of space.
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub facts: Vec<(String, String)>,

    /// The `images` property allows for the inclusion of a photo gallery inside
    /// a section. That photo gallery will always be displayed in a way that is
    /// easy to consume regardless of the form factor of the device it is being
    /// viewed on. For instance, in Outlook on the Web, images might be displayed
    /// as a horizontal strip of thumbnails with controls allowing to scroll
    /// through the collection if it doesn't all fit on the screen. On mobile,
    /// images might be displayed as a single thumbnail, with the user able to
    /// swipe through the collection with their finger.
    #[serde(skip_serializing_if = "Vec::is_empty")]
    pub images: Vec<Image>,

    /// A collection of [`actions`] that can be invoked on this section.
    /// 
    /// [`actions`]: struct.Action.html
    #[serde(rename = "potentialAction", skip_serializing_if = "Vec::is_empty")]
    pub potential_action: Vec<Action>,
}

#[derive(Debug, Default, Clone, PartialEq, Eq, Serialize)]
pub struct Image {
    /// The URL to the image.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub image: String,

    /// A short description of the image. Typically, `title` is displayed in a tooltip as the user hovers their mouse over the image.
    #[serde(skip_serializing_if = "String::is_empty")]
    pub title: String,
}

#[derive(Debug, Clone, PartialEq, Eq, Serialize)]
pub enum Action {
    OpenUri,
    HttpPOST,
    ActionCard,
    InvokeAddInCommand,
    None,
}

impl Action {
    pub fn is_none(&self) -> bool {
        matches!(self, Action::None)
    }
}

impl Default for Action {
    fn default() -> Self {
        Action::None
    }
}

fn usize_is_zero(x: &usize) -> bool {
    *x == 0
}

fn optional_bool<S>(val: &Option<bool>, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer
{
    let v = match *val {
        Some(b) => b,
        None => false,
    };
    s.serialize_bool(v)
}

fn optional_image<S>(val: &Option<bool>, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer
{
    match *val {
        Some(v) => v.serialize(s),
        None => s.serialize_none(),
    }
}

#[cfg(test)]
mod tests {
    #[test]
    fn it_works() {
        assert_eq!(2 + 2, 4);
    }
}
